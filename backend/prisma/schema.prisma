generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum TaskStatus {
  PENDING_APPROVAL
  ACTIVE
  AWAITING_REVIEW
  COMPLETED
}

enum Role {
  CITIZEN
  MAYOR
  MINISTER
  PM
  ADMIN
}

model User {
  id       String @id @default(uuid())
  username String @unique
  email    String @unique
  password String

  role             Role    @default(CITIZEN)
  refreshTokenHash String?

  socialScore Int @default(50)

  // one user belongs to one room
  roomId String
  room   Room   @relation(fields: [roomId], references: [id], onDelete: Restrict)

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  createdTasks    Task[]           @relation("TaskCreatedBy")
  assignedTasks   Task[]           @relation("TaskAssignedTo")
  mayorOfRooms    Room[]           @relation("RoomMayor")
  chatMemberships ChatRoomMember[]
  sentMessages    ChatMessage[]

  @@index([roomId])
}

model Department {
  id   String @id @default(uuid())
  name String @unique

  rooms Room[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Room {
  id           String @id @default(uuid())
  roomNumber   String
  departmentId String

  department Department @relation(fields: [departmentId], references: [id], onDelete: Restrict)
  users      User[]
  mayorId    String?
  mayor      User?      @relation("RoomMayor", fields: [mayorId], references: [id], onDelete: SetNull)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  tasks     Task[]
  chatRoom  ChatRoom?

  @@unique([departmentId, roomNumber])
  @@index([departmentId])
  @@index([mayorId])
}

model Task {
  id          String  @id @default(uuid())
  title       String
  description String?

  status TaskStatus @default(PENDING_APPROVAL)

  roomId String
  room   Room   @relation(fields: [roomId], references: [id], onDelete: Restrict)

  createdById String
  createdBy   User   @relation("TaskCreatedBy", fields: [createdById], references: [id], onDelete: Restrict)

  assignedToId String?
  assignedTo   User?   @relation("TaskAssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)

  // NEW: completion + review fields
  completionSummary String?
  completedAt       DateTime?

  mayorReviewNote String?
  reviewedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([roomId])
  @@index([createdById])
  @@index([assignedToId])
  @@index([status])
}

enum ChatRoomType {
  ROOM
  // later: DEPARTMENT, GLOBAL, FACTION
}

model ChatRoom {
  id   String       @id @default(uuid())
  type ChatRoomType @default(ROOM)

  /// ROOM chat: exactly one ChatRoom per Room
  roomId String? @unique
  room   Room?   @relation(fields: [roomId], references: [id], onDelete: Cascade)

  members  ChatRoomMember[]
  messages ChatMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
}

model ChatRoomMember {
  id         String @id @default(uuid())
  chatRoomId String
  userId     String

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Optional moderation features for later
  mutedUntil DateTime?

  joinedAt DateTime @default(now())

  @@unique([chatRoomId, userId])
  @@index([userId])
  @@index([chatRoomId])
}

model ChatMessage {
  id         String @id @default(uuid())
  chatRoomId String
  senderId   String

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  sender   User     @relation(fields: [senderId], references: [id], onDelete: Restrict)

  content   String
  deletedAt DateTime?

  createdAt DateTime @default(now())

  @@index([chatRoomId, createdAt])
  @@index([senderId])
}
